\section{Hiện thực hệ thống} \label{sec:hienthuchethong}
Trong chương này, chúng tôi sẽ trình bày chi tiết về kỹ thuật cách rút trích các đặc trưng, hiện thực bộ phân loại cũng như cách tích hợp các yếu tố đó vào hệ thống. Ngôn ngữ lập trình được sử dụng là Python, phiên bản 2.7.

\subsection{Thư viện và công cụ sử dụng}
\subsubsection*{MetaMap}
MetaMap cung cấp 3 phương pháp cơ bản để nhận diện các khái niệm trong kho dữ liệu UMLS-Metathesaurus từ dữ liệu đầu vào:
\begin{itemize}
\item Tương tác trực tiếp thông qua giao diện web\footnote{https://ii.nlm.nih.gov/Interactive/UTS\_Required/metamap.shtml} (\term{Use MetaMap Interactively}): MetaMap cung cấp giao diện web (Hình~\ref{fig:mmweb}) giúp người dùng, đặc biệt là người mới sử dụng, có cái nhìn trực quan nhất về cách MetaMap hoạt động bao gồm cấu trúc dữ liệu đầu vào và đầu ra, những tùy chọn và cách các tùy chọn này ảnh hưởng đến kết quả phân tích. Tuy nhiên, mỗi lần gửi dữ liệu lên máy chủ MetaMap thông qua giao diện web này, MetaMap giới hạn dữ liệu đầu vào chỉ có một tập tin dữ liệu dạng text chứa không quá 10000 ký tự vì thế không thể sử dụng cách này cho những mẩu dữ liệu quá dài. Hơn nữa việc gửi và nhận kết quả trực tuyến thông qua mạng nên không đảm bảo tốc độ xử lý và bảo mật dữ liệu. Với những hạn chế vừa nêu, sau khi đã làm quen với cách hoạt động của MetaMap, người dùng có thể chọn 2 cách sau để tương tác với MetaMap.
\item Gửi tập dữ liệu lên máy chủ MetaMap\footnote{https://ii.nlm.nih.gov/Batch/UTS\_Required/metamap.shtml} (\term{Use Batch MetaMap}): người dùng có thể gửi bộ dữ liệu lên máy chủ của MetaMap (Hình~\ref{fig:batchmm}), sau quá trình xử lý MetaMap sẽ trả kết quả về địa chỉ email người dùng cung cấp. Ưu điểm của phương pháp này là tốc độ xử lý nhanh do không có tương tác trong quá trình phân tích dữ liệu. Tuy nhiên khi xảy ra lỗi trong quá trình chạy thì khó phán đoán được lỗi xảy ra ở mẩu dữ liệu nào. 
\item Sử dụng MetaMap cục bộ (\term{Use MetaMap Locally}): Nếu người dùng muốn hoàn toàn kiểm soát dữ liệu của mình thì việc cài đặt MetaMap ngay trên máy tính cá nhân là lựa chọn tốt nhất. Ưu điểm của phương pháp này là tốc độ xử lý nhanh, không phụ thuộc vào hệ thống mạng do không cần gửi dữ liệu lên máy chủ MetaMap, đảm bảo quyền kiểm soát dữ liệu và khả năng điều chỉnh cấu trúc kết quả phù hợp với nhu cầu sử dụng. Tuy nhiên nhược điểm lớn của phương pháp này là tốn khá nhiều tài nguyên hệ thống và cần máy tính có cấu hình đủ mạnh để làm máy chủ cục bộ.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{../hinh/mmweb.png}
\caption{Giao diện web tương tác trực tiếp của MetaMap}
\label{fig:mmweb}
\end{figure}

Kết quả xử lý trả về như nhau khi dùng cả 3 phương pháp. Trong hệ thống phân loại chúng tôi đã dùng MetaMap cục bộ để tối đa khả năng điều chỉnh cấu trúc dữ liệu đầu ra. \\

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{../hinh/batchmm.png}
\caption{Batch MetaMap}
\label{fig:batchmm}
\end{figure}

Trong phạm vi luận văn, chúng tôi sử dụng công cụ MetaMap để xác định các nhãn y khoa tồn tại trong câu dữ liệu đầu vào. Chúng tôi đã tùy chọn bộ lọc nhãn từ vựng thuộc các nhóm ngữ nghĩa liên quan trực tiếp tới các triệu chứng, nguyên nhân, bệnh lý lâm sàng và cận lâm sàng gồm \term{Pathologic Function}, \term{Disease or Syndrome}, \term{Mental or Behavioral Dysfunction}, \term{Cell or Molecular Dysfunction}, \term{Virus}, \term{Neoplastic Process}, \term{Anatomical Abnormality}, \term{Acquired Abnormality}, \term{Congenital Abnormality}, \term{Injury or Poisoning}.\\

Trong quá trình sử dụng MetaMap, chúng tôi chỉnh tùy chọn \myquote{-negex} để lấy được kết quả đầu ra có phân tích phủ định. Đồng thời chúng tôi cũng xây dựng một chương trình con gọi là NegEx sử dụng giải thuật phân tích phủ định NegEx\footnote{https://code.google.com/p/negex/wiki/NegExAlgorithmDescription} để so sánh với kết quả từ MetaMap.

\subsection{Hiện thực rút trích đặc trưng}
Trong phần này, chúng tôi trình bày cách thức hiện thực để ánh xạ một câu thành một vector. Các đặc trưng sẽ nhận vào danh sách $n$ câu, hệ thống sẽ cho ra một mảng 2 chiều: $(n*m)$, với $m$ là số chiều tùy thuộc mỗi đặc trưng. Từ đó làm input cho giải thuật học máy SVM.
\subsubsection*{Đặc trưng N-gram}
Scikit-learn cung cấp các công cụ để làm việc với dữ liệu dạng text. Trong số này, chúng tôi sử dụng module sklearn.feature\_extraction.text.CountVectorizer để hiện thực đặc trưng N-gram. Như mô tả ở mục \ref{sec:ngram}, n-gram được trích xuất qua 2 bước:\\

Bước đầu tiên: Xây dựng tập từ vựng T. Scikit-learn cung cấp lớp CountVectorizer cho tác vụ này.
\begin{lstlisting}
vectorizer = CountVectorizer(input, min_df, binary, ngram_range)
\end{lstlisting}
Hàm khởi tạo CountVectorizer cung cấp 17 tham số, tuy nhiên, trong nghiên cứu này chúng tôi chỉ quan tâm đến 4 tham số, các tham số còn lại sử dụng giá trị mặc định:
\begin{description}
\item[input] Là các câu trong tập dữ liệu huấn luyện
\item[min\_df] Là số nguyên thể hiện số câu câu ít nhất chứa n-gram để n-gram đó được thêm vào tập từ vựng. Tham số này đã được giải thích chi tiết tại \ref{sec:ngram}
\item[binary] Là giá trị True hoặc False. Nếu $binary=True$, giải thuật sử dụng \term{vector nhị phân}\footnotemark, \footnotetext{2 khái niệm này được định nghĩa tại Mục \ref{sec:ngram}, phần Rút trích}
ngược lại sử dụng \term{vector số nguyên}\footnotemark
 \footnotetext{2 khái niệm này được định nghĩa tại Mục \ref{sec:ngram}, phần Rút trích}
 \item[ngram\_range] Là một \term{tuple}, có dạng $(a, b)$. Giải thuật sẽ sử dụng các loại n-gram từ a-gram đến b-gram. \\
 Ví dụ $ngram\_range = (1,3)$: Giải thuật sử dụng 3 loại n-gram: Uni-gram, bi-gram và tri-gram.
\end{description}

Bước thứ 2: xây dựng tập vector đại diện cho mỗi câu trong tập huấn luyện. Bước này được thực hiện bằng cách gọi hàm:
\begin{lstlisting}
vectors-ngram = vectorizer.transform(raw_documents).toarray()
\end{lstlisting}
trong đó $raw\_documents$ là tập hợp các câu. Hàm trên trả về một mảng 2 chiều $n*m$ với n là số lượng câu trong tập $raw\_documents$ và $m$ là kích thước của tập từ vựng (Hình \ref{fig:hien-thuc-ngram}).
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{../hinh/hien_thuc_ngram.png}
\caption{Hiện thực đặc trưng N-gram} \label{fig:hien-thuc-ngram}
\end{figure}
\subsubsection*{Đặc trưng n-gram kết hợp Metamap}
Chúng tôi sử dụng thư viện Metamap để nhận dạng các từ chuyên ngành trong y khoa, sau đó thay các từ chuyên ngành bằng nhãn ngữ nghĩa của từ đó. 
Việc sử dụng n-gram kết hợp Metamap trải qua 2 bước (Hình \ref{fig:hien-thuc-metamap}):
\begin{itemize}
\item[•] Tập dữ liệu sẽ được cho qua khối xử lý Metamap để tạo ra 1 tập dữ liệu mới với các từ chuyên ngành đã được thay thế bởi nhãn ngữ nghĩa.
\item[•] Tập dữ liệu mới đi qua khối n-gram để cho ra mảng 2 chiều $n*m$ như mô tả ở trên.
\end{itemize}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{../hinh/hien_thuc_metamap.png}
\caption{Hiện thực đặc trưng N-gram kết hợp Metamap} \label{fig:hien-thuc-metamap}
\end{figure}
\subsubsection*{Đặc trưng Chang phrase}
Đặc trưng Change phrase ánh xạ một câu sang 1 vector 4 chiều. Trong phần hiện thực, chúng tôi định nghĩa hàm training\_change\_phrase:
\begin{lstlisting}
def training_change_phrase(raw_documents):
\end{lstlisting}
Hàm nhận vào danh sách các câu trong tập dữ liệu, sau đó trả về mảng 2 chiều $n*4$ với $n$ là số lượng câu trong tập $raw\_documents$ (Hình \ref{fig:hien-thuc-changephrase})
\begin{figure}
\centering
\includegraphics[scale=0.5]{../hinh/hien_thuc_changephrase.png}
\caption{Hiện thực đặc trưng Thay đổi trạng thái} \label{fig:hien-thuc-changephrase}
\end{figure}
\subsubsection*{Đặc trưng phủ định}
Với dữ liệu đầu vào là câu dạng ngôn ngữ tự nhiên, chúng tôi xây dựng 2 công cụ để xác định thành phần phủ định trong câu:
\begin{itemize}
\item Meta-NegEx: dùng tùy chọn \myquote{-negex} để lấy được kết quả phân tích của MetaMap có chứa từ phủ định và phạm vi phủ định. Kết quả lưu lại dưới dạng JSON như Hình~\ref{fig:Meta-NegEx}.
\item Gen-NegEx: dựa vào giải thuật phân tích phủ định NegEx đã mô tả ở Mục \ref{sec:su-phu-dinh}, chúng tôi xây dựng chương trình với kết quả đầu ra là câu dữ liệu đã được xác định thành phần và phạm vi phủ định. <Thêm ví dụ>
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[scale=0.35]{../hinh/JSON.png}
\caption{Ví dụ kết quả phân tích phủ định dùng công cụ MetaMap}
\label{fig:Meta-NegEx}
\end{figure}

Việc hiện thực song song hai công cụ phân tích phủ định nhằm so sánh hiệu quả của chúng và chọn ra công cụ phù hợp nhất.\\

Với Meta-NegEx, công cụ hỗ trợ phiên bản local được cung cấp miễn phí. Một kết quả phân tích thử nghiệm như Hình\\
HÌNH\\

Với Gen-NegEx, chúng tôi sử dụng mã nguồn của/tại.. Tương tự, kết quả phân tích 1 câu như Hình \\
HÌNH

Kết quả của 2 công cụ được xử lý để đưa về chung 1 cấu trúc, sau đó lưu vào file. Việc này giúp dễ dàng tích hợp yếu tố vào hệ thống các đặc trưng mà không quan tâm tới quá trình trích xuất bằng công cụ nào.

Như mô tả ở \ref{subsec:negation}, chúng tôi hiện thực việc sử dụng đặc trưng phủ định theo 3 cách chính:
\begin{itemize}
\item[•] Với 2 cách đầu, khối xử lý phủ định nhận vào tập dữ liệu và cho ra một tập dữ liệu mới với nhãn NEGATION thay thế các từ phủ định (Hình \ref{fig:hien-thuc-negation-1}), hoặc hậu tố \_NEG được thêm vào sau các từ bị phủ định (Hình \ref{fig:hien-thuc-negation-2})
\item[•] Với cách hiện thực thứ 3, khối xử lý phủ định nhận vào tập dữ liệu và cho ra mảng $(n*1)$ với $n$ là kích thước tập dữ liệu (Hình \ref{fig:hien-thuc-negation-3}).
\end{itemize}
\begin{figure}
\begin{subfigure}{0.33\textwidth}
\centering
\includegraphics[scale=0.3]{../hinh/hien_thuc_negation.png}
\caption{Hiện thực đặc trưng Phủ định theo cách 1} \label{fig:hien-thuc-negation-1}
\end{subfigure}
~
\begin{subfigure}{0.3\textwidth}
\centering
\includegraphics[scale=0.3]{../hinh/hien_thuc_negation.png}
\caption{Hiện thực đặc trưng Phủ định theo cách 2} \label{fig:hien-thuc-negation-2}
\end{subfigure}
~
\begin{subfigure}{0.3\textwidth}
\centering
\includegraphics[scale=0.3]{../hinh/hien_thuc_negation.png}
\caption{Hiện thực đặc trưng Phủ định theo cách 3} \label{fig:hien-thuc-negation-3}
\end{subfigure}
\end{figure}


\subsubsection*{SO-CAL}
Trong phần này, chúng tôi sử dụng phiên bản hiện thực của nghiên cứu \cite{taboada2011lexicon}. Nhóm tác giả của nghiên cứu \cite{taboada2011lexicon} đã hiện thực công cụ online để tính điểm số cho 1 đoạn văn, giao diện được mô tả như Hình \ref{fig:socal}.
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.4\textwidth}
\includegraphics[scale=0.3]{../hinh/socal.png}
\caption{Nhập 1 đoạn text sau đó nhấp submit để chuyển đến trang kết quả}
\end{subfigure}
~
\begin{subfigure}[b]{0.4\textwidth}
\includegraphics[scale=0.3]{../hinh/socal_result.png}
 \caption{Giao diện kết quả}
\end{subfigure}
\caption{Công cụ online để tính điểm SO-CAL} \label{fig:socal}
\end{figure}

Để tích hợp vào hệ thống, nhóm sử dụng package \code{re} trong Python, sử dụng phương thức \code{HTTP POST} để gửi yêu cầu lên trang web, sau đó \term{parser} phần kết quả trả về để lấy ra thông tin điểm số. Kết quả đầu ra khi rút trích đặc trưng SO-CAL là ma trận (m*1) với m là kích thước tập dữ liệu (Hình \ref{fig:hien-thuc-socal}).
\begin{figure}
\centering
\includegraphics[scale=0.5]{../hinh/hien_thuc_socal.png}
\caption{Hiện thực đặc trưng SO-CAL} \label{fig:hien-thuc-socal}
\end{figure}
\subsection{Hiện thực bộ phân loại SVM}
\begin{figure}[H]
\centering
\includegraphics[scale=0.25]{../hinh/kethopdactrung.png}
\caption{Kết hợp các đặc trưng trước khi đưa vào SVM huấn luyện} \label{fig:ket-hop-dac-trung}
\end{figure}
Các đặc trưng sau khi được rút trích như đã mô tả sẽ được kết hợp lại để với mỗi câu, chỉ có 1 vector đại diện. Mô hình kết hợp các đặc trưng được miêu tả như Hình \ref{fig:ket-hop-dac-trung}

Chúng tôi sử dụng lớp SVM.SVC của thư viện Scikit-learn để hiện thực giải thuật học máy SVM.\\
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}
clf = svm.SVC(decision_function_shape = 'ovr', C = c,           kernel = 'rbf', class_weight = 'balanced')
clf.fit(data_x, data_y)
\end{lstlisting}
\end{minipage}

Hàm khởi tạo SVM.SVC ở dòng 1 có các tham số được sử dụng như sau:
\begin{description}
\item[decision\_function\_shape] Định nghĩa cách SVC hiện thực bộ phân loại đa lớp. Nếu decision\_function\_shape='ovr' (one-vs-rest), SVC tạo ra 3 hàm quyết định (decision function): Một câu có thuộc lớp \tichcuc hay không, một câu có thuộc lớp \tieucuc hay không và một câu có thuộc lớp \trungtinh hay không. Nếu decision\_function\_shape='ovo' (one-vs-one), SVC tạo ra 3 hàm quyết định: Một câu thuộc lớp \tichcuc hay thuộc lớp \tieucuc, một câu thuộc lớp \tieucuc hay thuộc lớp \trungtinh và một câu thuộc lớp \trungtinh hay thuộc lớp \tichcuc
\item[C] là hệ số được định nghĩa trong mô hình soft-margin của giải thuật SVM. Hệ số này đánh đổi giữa việc chấp nhận 1 vài dữ liệu bị phân loại sai, bù lại việc mặt phẳng hàm quyết định (decision surface) trở nên phức tạp, ít tuyến tính. C cao thì SVC càng phân loại chính xác các dữ liệu trong tập huấn luyện, ngược lại C thấp thì mặt phẳng hàm quyết định càng đơn giản.
\item[kernel] Định nghĩa loại \term{kernel} SVC sử dụng: linear, poly, rbf, sigmoid, precomputed
\item[class\_weight] Tùy chọn cách xử lý khi số lượng các lớp trong tập huấn luyện bị chêch lệch
\end{description}

Sau khi khởi tạo, hàm clf.fit(data\_x, data\_y) được gọi với data\_x là dữ liệu tập huấn luyện sau khi đã qua các bước rút trính đặc trưng để ánh xạ từ 1 câu sang 1 vector, data\_y là vector chứa nhãn tương ứng.
\subsection{Hiện thực phương pháp cross-validation}
Chúng tôi sử dụng cross-validation để điều chỉnh tham số $C$ trong giải thuật SVM. Với các thử nghiệm, chúng tôi thử nghiệm với giá trị $C$ lần lượt 1, 10, 100, 500, 1000. Sau đó, chúng tôi co hẹp dần khoảng giá trị $C$ và nhận thấy $C \in [25, 35]$ đạt hiệu quả tốt nhất. Từ đó, với mỗi thử nghiệm được trình bày ở mục \ref{subsec:ket-qua-thi-nghiem}, chúng tôi thử các giá trị $C \in [25, 35]$ và chọn ra $C$ với kết quả tốt nhất. Một ví dụ thể hiện sự phụ thuộc độ đo F vào $C$ được mô tả như Hình \
